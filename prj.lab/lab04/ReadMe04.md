## **Лабораторная 04 (бинаризация и простое детектирование объектов)**
1.	написать функцию для генерации тестового изображения (количество объектов интереса, диапазон размеров, значений контраста и степени размытости - параметры)
2.	написать несколько вариантов бинаризации (параметризованной)
3.	предусмотреть режим визуальной настройки параметров бинаризации (движки в GUI)
4.	написать функционал для детектирования
5.	написать функционал для оценки качества (на основе IoU при заданном уровне сделать подсчет количества TP, FP и FN детекций)


## **Отчет 04**
	 
Функциональность:

	void binaryThreshold(const cv::Mat& src, cv::Mat& dst, int threshold) – функция для бинаризации изображения посредством трешхолда (ползунка).
 
	void evaluateDetections(const std::vector<cv::Vec3f>& detections, const std::vector<cv::Vec3f>& groundTruths, double iouThreshold) – функция для оценки детекции, подсчитывание следующих параметров: TP (True positive), FP (false positive), FN (false negative). На вход функция принимает вектор найденных кругов, вектор размеченных кругов и значение с трешхолда.
 
	void createGroundTruth(cv::Mat& img, std::vector<cv::Vec3f>& groundTruths) - Функция для создания изображения и разметки ground truth
 
 	void adaptiveThresholding(const cv::Mat& src, cv::Mat& dst, int blockSize, double C) - функция для оконной бинаризации
  
  	void otsuThresholding(const cv::Mat& src, cv::Mat& dst) - метод бинаризации Оцу
   
   	void detectAndEvaluateCircles(const cv::Mat& binaryImg, const cv::Mat& src, const std::vector<cv::Vec3f>& groundTruths, double iouThreshold) - Функция для детекции окружностей и оценка детекций

### Результат работы программы: 
	В отчете будут продемонстрированы картинки с разным кол-вом кругов на них: 10, 25, 50, 100, 256. Но сначала мы рассмотрим возможные методы бинаризации - обычный (Treshold), Оконный, Метод Оцу на примере для 50 кругов. Также на примере 50 кругов рассмотрим алгоритм работы кода.

#### Полный алгоритм
 Сгенерированная картинка с 50 кругами разных размеров и яркостей, расположенных по возрастанию яркости и размера окружностей:

 ![Orig_50](/prj.lab/lab04/Cir_50/Original_Image.jpg)

Далее накладываем на картинку размытие с помощью функции: cv::GaussianBlur(img, BlurPic, cv::Size(Ks, Ks), blur);
Затем накладываем шум с помощью функции cv::Mat addNoise(const cv::Mat& orig_im, double noise_sigm). Полученная картинка будет подвережена обработке:

![Noize_50](/prj.lab/lab04/Cir_50/Noisy_Image.jpg)
 
Также для бинаризации и в качестве GUI был реализован трек бар, одинаковый для всех кратинок:

![TrackBar](/prj.lab/lab04/TrackBar.png)

Было рассмотрено 3 метода бинаризации:

![Tresh_50](/prj.lab/lab04/Cir_50/Binary_with_Trackbars.jpg) - Классическая бинаризация

![Adapt_50](/prj.lab/lab04/Binary_with_Trackbars_Adaptive.jpg) - Оконная бинаризация

![Otsu_50](/prj.lab/lab04/Binary_with_Trackbars_Otsu.jpg) - Метод Оцу

#### Применение детекции

После бинаризации к каждой картинке была применена функция детекции с оценкой качества детекции (вывод непосредственно на картинке)

![Tresh_50](/prj.lab/lab04/Cir_50/detected_image.jpg) - Классическая бинаризация

![Adapt_50](/prj.lab/lab04/detected_image_Adaptive.jpg) - Оконная бинаризация

![Otsu_50](/prj.lab/lab04/detected_image_Otsu.jpg) - Метод Оцу


#### Сравнение
При сравнении приведенных выше картинок, можно сделать вывод, что все методы бинаризации, кроме классического дают не очень хороший результат. Поэтому дальнейшее изучение программы на других картинках будет с помощью классической бинаризации.

### 10 окружностей

Проведение бинаризации

![Tresh_10](/prj.lab/lab04/Cir_10/Binary_with_Trackbars_10.jpg)

Детекция бинаризованной картинки
![Tresh_10](/prj.lab/lab04/Cir_10/detected_image_10.jpg)

### 25 окружностей

Проведение бинаризации

![Treh_25](/prj.lab/lab04/Cir_25/Binary_with_Trackbars_25.jpg)

Детекция бинаризованной картинки
![Tresh_25](/prj.lab/lab04/Cir_25/detected_image_25.jpg)

### 100 окружностей

Проведение бинаризации

![Tresh_100](/prj.lab/lab04/Cir_100/Binary_with_Trackbars_100.jpg)

Детекция бинаризованной картинки
![Tresh_100](/prj.lab/lab04/Cir_100/detected_image_100.jpg)

### 256 окружностей

Проведение бинаризации

![Tresh_256](/prj.lab/lab04/Cir_256/Binary_with_Trackbars_256.jpg)

Детекция бинаризованной картинки
![Tresh_256](/prj.lab/lab04/Cir_256/detected_image_256.jpg)


## Выводы

Можем заметить, что детекция картинок работает хуже при больше количестве кругов при условии их размеров (чем больше кругов на картинке, тем они меньше)
