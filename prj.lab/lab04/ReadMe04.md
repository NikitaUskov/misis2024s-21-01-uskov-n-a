## **Лабораторная 04 (бинаризация и простое детектирование объектов)**
1.	написать функцию для генерации тестового изображения (количество объектов интереса, диапазон размеров, значений контраста и степени размытости - параметры)
2.	написать несколько вариантов бинаризации (параметризованной)
3.	предусмотреть режим визуальной настройки параметров бинаризации (движки в GUI)
4.	написать функционал для детектирования
5.	написать функционал для оценки качества (на основе IoU при заданном уровне сделать подсчет количества TP, FP и FN детекций)


## **Отчет 04**
	 
Функциональность:

	void binaryThreshold(const cv::Mat& src, cv::Mat& dst, int threshold) – функция для бинаризации изображения посредством трешхолда (ползунка).
 
	void evaluateDetections(const std::vector<cv::Vec3f>& detections, const std::vector<cv::Vec3f>& groundTruths, double iouThreshold) – функция для оценки детекции, подсчитывание следующих параметров: TP (True positive), FP (false positive), FN (false negative). На вход функция принимает вектор найденных кругов, вектор размеченных кругов и значение с трешхолда.
 
	void createGroundTruth(cv::Mat& img, std::vector<cv::Vec3f>& groundTruths) - Функция для создания изображения и разметки ground truth
 
 	void adaptiveThresholding(const cv::Mat& src, cv::Mat& dst, int blockSize, double C) - функция для оконной бинаризации
  
  	void otsuThresholding(const cv::Mat& src, cv::Mat& dst) - метод бинаризации Оцу
   
   	void detectAndEvaluateCircles(const cv::Mat& binaryImg, const cv::Mat& src, const std::vector<cv::Vec3f>& groundTruths, double iouThreshold) - Функция для детекции окружностей и оценка детекций

### Результат работы программы: 
	В отчете будут продемонстрированы картинки с разным кол-вом кругов на них: 10, 25, 50, 100, 256. Но сначала мы рассмотрим возможные методы бинаризации - обычный (Treshold), Оконный, Метод Оцу на примере для 50 кругов:

 Сгенерированная картинка с 50 кругами разных размеров и яркостей, расположенных по возрастанию яркости и размера окружностей.

 ![Orig_50](/prj.lab/lab04/Cir_50/Original_Image_50.jpg)

Далее накладываем на картинку размытие с помощью функции: cv::GaussianBlur(img, BlurPic, cv::Size(Ks, Ks), blur);
Затем накладываем шум с помощью функции cv::Mat addNoise(const cv::Mat& orig_im, double noise_sigm). Полученная картинка будет подвережена обработке:

 ![FinalyPic](/prj.lab/lab04/ReallyPic.png)
 
Далее необходимо разметить картинку, чтобы потом было с чем сравнивать детектирование:

![TruePic](/prj.lab/lab04/TruePic.png)

Далее проводим бинаризацию картинки 2 методами, общая и оконная:

Для опредления "оптимального" порога бинаризации был сделан ползунок: void onTrackbar(int, void*). Оптимальным порогом бинаризации было выбрано значение: 128

Общая бинаризация проводится следующим методом: cv::threshold(src, dst, threshold, 255, cv::THRESH_BINARY)

![BinaryPic](/prj.lab/lab04/binaryPic.png)

Оконная бинаризация проводится следующим методом: cv::adaptiveThreshold(window, binaryWindow, 255, cv::ADAPTIVE_THRESH_MEAN_C, cv::THRESH_BINARY, blockSize, C);

![BinaryWinPic](/prj.lab/lab04/binaryWindow.png)

Далее были применены методы детектции Хафф на бинаризованные картинки, получили следующие результаты:

Порог бинаризации 128: TP: 59, FP: 4, FN: 41

![Det128Pic](/prj.lab/lab04/Bin128.png)

Порог бинаризации 162: TP: 51, FP: 0, FN: 49

 ![Det162Pic](/prj.lab/lab04/Bin162.png)

Для детектирования оконной бинаризации был использован тот же метод:

TP: 69, FP: 20, FN: 31

![DetWindowBin](/prj.lab/lab04/WindowDetection.png)


Выводы данной лабораторной:
Оконная бинаризация "лучше" выделяет контуры кругов, но общий шум остается в среднем, это позволяет определять круги лучше из-за четкого наличия контуров. Общая бинаризация хорошо выделяет сами круги, но больше стирает их границы, что делает их набором точек, сложным для детектирования. В данном случае видим, что детекция общей бинаризации "чище", но меньше, чем у оконной.
