**Лабораторная 04 (бинаризация и простое детектирование объектов)**
1.	написать функцию для генерации тестового изображения (количество объектов интереса, диапазон размеров, значений контраста и степени размытости - параметры)
2.	написать несколько вариантов бинаризации (параметризованной)
3.	предусмотреть режим визуальной настройки параметров бинаризации (движки в GUI)
4.	написать функционал для детектирования
5.	написать функционал для оценки качества (на основе IoU при заданном уровне сделать подсчет количества TP, FP и FN детекций)


**Отчет 04**
	 
Функциональность:

	void binaryThreshold(const cv::Mat& src, cv::Mat& dst, int threshold) – функция для бинаризации изображения посредством трешхолда (ползунка).
 
	void evaluateDetections(const std::vector<cv::Vec3f>& detections, const std::vector<cv::Vec3f>& groundTruths, double iouThreshold) – функция для оценки детекции, подсчитывание следующих параметров: TP (True positive), FP (false positive), FN (false negative). На вход функция принимает вектор найденных кругов, вектор размеченных кругов и значение с трешхолда.
 
	void createGroundTruth(cv::Mat& img, std::vector<cv::Vec3f>& groundTruths) – функция для разметки изображения для будущего оценивания результативности программы.

Результат работы программы: 
	Изначальная картинка для детектирования кругов:
 ![Img](/prj.lab/lab04/img.png)

Далее накладываем на картинку размытие с помощью функции: cv::GaussianBlur(img, BlurPic, cv::Size(Ks, Ks), blur);
Затем накладываем шум с помощью функции cv::Mat addNoise(const cv::Mat& orig_im, double noise_sigm). Полученная картинка будет подвережена обработке:

 ![FinalyPic](/prj.lab/lab04/ReallyPic.png)
 
Далее необходимо разметить картинку, чтобы потом было с чем сравнивать детектирование:

![TruePic](/prj.lab/lab04/TruePic.png)

Далее проводим бинаризацию картинки 2 методами, общая и оконная:

Для опредления "оптимального" порога бинаризации был сделан ползунок: void onTrackbar(int, void*). Оптимальным порогом бинаризации было выбрано значение: 128

Общая бинаризация проводится следующим методом: cv::threshold(src, dst, threshold, 255, cv::THRESH_BINARY)

![BinaryPic](/prj.lab/lab04/binaryPic.png)

Оконная бинаризация проводится следующим методом: cv::adaptiveThreshold(window, binaryWindow, 255, cv::ADAPTIVE_THRESH_MEAN_C, cv::THRESH_BINARY, blockSize, C);

![BinaryWinPic](/prj.lab/lab04/binaryWindow.png)

Далее были применены методы детектции Хафф на бинаризованные картинки, получили следующие результаты:

Порог бинаризации 128: TP: 59, FP: 4, FN: 41

![Det128Pic](/prj.lab/lab04/Bin128.png)

Порог бинаризации 162: TP: 51, FP: 0, FN: 49

 ![Det162Pic](/prj.lab/lab04/Bin162.png)

Для детектирования оконной бинаризации был использован тот же метод:

TP: 51, FP: 0, FN: 49

![DetWindowBin](/prj.lab/lab04/WindowDetection.png)
